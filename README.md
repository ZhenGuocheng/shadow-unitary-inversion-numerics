# shadow-unitary-inversion-numerics

This repository contains

  * Reproducibility code for the numerical experiments (Table I) in “Structure, Optimality, and Symmetry in Shadow Unitary Inversion” (Zhen, Chen, Jing, Xie, Chen, Wang; 2025)
  * SDP (semidefinite programming) codes to compute the optimal shadow unitary inversion of an unknown **2-dimensional unitary** using sequential/parallel quantum combs
  * A Python/SageMath notebook to generate the Schur-transform matrices used in the SDP simplification

These codes are accompanied to the following manuscript:

  * Zhen, Chen, Jing, Xie, Chen, Wang, “Structure, Optimality, and Symmetry in Shadow Unitary Inversion” (2025), [arXiv:2510.24880](https://arxiv.org/abs/2510.24880).

## Requirement

The SDP code to solve the optimal shadow inversion of an unknown unitary is written in MATLAB and requires the following interpreter:

  * [CVX](https://cvxr.com/cvx/): a MATLAB-based convex modeling framework

These codes also use functions of QETLAB ([QETLAB](http://www.qetlab.com/): A MATLAB Toolbox for Quantum Entanglement), but all used functions are contained in the subfolder [QETLAB_used_functions](QETLAB_used_functions).

It has been tested on [MATLAB](https://www.mathworks.com/products/matlab.html) R2024a and CVX 2.2.

The Schur-transform code is written in a Jupyter notebook and has been tested on:

  * [Python](https://www.python.org/) 3.11.11
  * [SageMath](https://www.sagemath.org/) 10.4

## Description

The main scripts of this repository are

  * [dual_comb_1qubit_1slot_simplify.m](dual_comb_1qubit_1slot_simplify.m): SDP code to obtain the optimal shadow inversion of an unknown 2-dimensional unitary using a **1-slot quantum comb**. (The 1-slot setting is both sequential and parallel.)

  * [dual_comb_1qubit_2slots_simplify.m](dual_comb_1qubit_2slots_simplify.m): SDP code to obtain the optimal shadow inversion of an unknown 2-dimensional unitary using a **2-slot sequential quantum comb**. This script uses the Schur matrix [U_sch.mat](U_sch.mat), which is generated by [Schur_transform.ipynb](Schur_transform.ipynb) (corresponding to `d=2, n=3`).

  * [dual_comb_1qubit_3slots_simplify.m](dual_comb_1qubit_3slots_simplify.m): SDP code to obtain the optimal shadow inversion of an unknown 2-dimensional unitary using a **3-slot sequential quantum comb**. This script uses the Schur matrix [U_sch_3slot.mat](U_sch_3slot.mat), which is generated by [Schur_transform.ipynb](Schur_transform.ipynb) (corresponding to `d=2, n=4`).

  * [dual_comb_1qubit_2slots_original_parallel.m](dual_comb_1qubit_2slots_original_parallel.m): SDP code to obtain the optimal shadow inversion of an unknown 2-dimensional unitary using a **2-slot parallel quantum comb**.

  * [dual_comb_1qubit_3slots_simplify_parallel.m](dual_comb_1qubit_3slots_simplify_parallel.m): SDP code to obtain the optimal shadow inversion of an unknown 2-dimensional unitary using a **3-slot parallel quantum comb**. This script also uses the Schur matrix [U_sch_3slot.mat](U_sch_3slot.mat), which is generated by [Schur_transform.ipynb](Schur_transform.ipynb) (corresponding to `d=2, n=4`).

  * [Schur_transform.ipynb](Schur_transform.ipynb): Python/SageMath notebook used to generate the Schur-transform matrices used in the SDP codes (saved as [U_sch.mat](U_sch.mat) and [U_sch_3slot.mat](U_sch_3slot.mat)).

## License

This code is under the [MIT license](LICENSE) (see also: [opensource.org/licenses/MIT](https://opensource.org/licenses/MIT)).
